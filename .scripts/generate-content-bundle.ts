const fsp = require('fs/promises');
const path = require('path');
const matter = require('gray-matter');
const dayjs = require('dayjs');

const BLOG_DIR = path.join(process.cwd(), 'blog');
const OUTPUT_DIR = path.join(process.cwd(), 'src', 'generated');
const OUTPUT_PATH = path.join(OUTPUT_DIR, 'content-bundle.ts');
const ABOUT_PATH = path.join(BLOG_DIR, 'about.md');

type BundledPostType = 'post' | 'daily';

type BundledPost = {
  slug: string;
  type: BundledPostType;
  filePath: string;
  fileName: string;
  fileNameBase: string;
  title: string | null;
  date: string | null;
  tags: string[];
  description: string;
  keywords: string[];
  content: string;
};

type ContentBundle = {
  generatedAt: string;
  posts: BundledPost[];
  about: {
    content: string;
  };
};

function isMarkdown(file: string): boolean {
  return file.toLowerCase().endsWith('.md');
}

function normalizeSlug(value: unknown): string {
  if (typeof value === 'string') return value.trim();
  if (value instanceof Date) return dayjs(value).format('YYYY-MM-DD');
  if (typeof value === 'number') return String(value);
  return '';
}

function normalizeDate(value: unknown): string | null {
  const parsed = dayjs(value as string | number | Date);
  if (!parsed.isValid()) return null;
  return parsed.format('YYYY-MM-DD');
}

function normalizeKeywords(value: unknown): string[] {
  if (Array.isArray(value)) return value.map(String).map((item) => item.trim()).filter(Boolean);
  if (typeof value === 'string') {
    return value
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean);
  }
  return [];
}

function normalizeTags(value: unknown): string[] {
  if (!Array.isArray(value)) return [];
  return value.map(String).map((tag) => tag.trim().toLowerCase()).filter(Boolean);
}

async function walkMarkdownFiles(dirPath: string): Promise<string[]> {
  const entries = await fsp.readdir(dirPath, { withFileTypes: true });
  const files = await Promise.all(entries.map(async (entry: import('fs').Dirent) => {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) return walkMarkdownFiles(fullPath);
    if (entry.isFile() && isMarkdown(entry.name)) return [fullPath];
    return [];
  }));
  return files.flat();
}

async function collectPostsFromDir(relativeDir: 'home' | 'daily', type: BundledPostType): Promise<BundledPost[]> {
  const dirPath = path.join(BLOG_DIR, relativeDir);
  const files = await walkMarkdownFiles(dirPath);
  const items: BundledPost[] = [];

  for (const fullPath of files) {
    const rel = path.relative(BLOG_DIR, fullPath).replace(/\\/g, '/');
    const filePath = rel;
    const fileName = path.basename(fullPath);
    const fileNameBase = fileName.replace(/\.md$/i, '');

    const raw = await fsp.readFile(fullPath, 'utf8');
    const parsed = matter(raw);
    const slug = normalizeSlug(parsed.data.slug);

    if (!slug) {
      continue;
    }

    const title = parsed.data.title ? String(parsed.data.title) : null;
    const date = normalizeDate(parsed.data.date);
    const description = parsed.data.description ? String(parsed.data.description) : '';

    items.push({
      slug,
      type,
      filePath,
      fileName,
      fileNameBase,
      title,
      date,
      tags: normalizeTags(parsed.data.tags),
      description,
      keywords: normalizeKeywords(parsed.data.keywords),
      content: parsed.content,
    });
  }

  return items;
}

async function loadAboutContent(): Promise<string> {
  const raw = await fsp.readFile(ABOUT_PATH, 'utf8');
  const parsed = matter(raw);
  return parsed.content;
}

async function ensureDir(dirPath: string): Promise<void> {
  await fsp.mkdir(dirPath, { recursive: true });
}

function renderTypeScript(bundle: ContentBundle): string {
  const serialized = JSON.stringify(bundle, null, 2);
  return `/* eslint-disable */\n// AUTO-GENERATED by .scripts/generate-content-bundle.ts\n// Do not edit manually.\n\nexport type BundledPostType = 'post' | 'daily';\n\nexport interface BundledPost {\n  slug: string;\n  type: BundledPostType;\n  filePath: string;\n  fileName: string;\n  fileNameBase: string;\n  title: string | null;\n  date: string | null;\n  tags: string[];\n  description: string;\n  keywords: string[];\n  content: string;\n}\n\nexport interface ContentBundle {\n  generatedAt: string;\n  posts: BundledPost[];\n  about: {\n    content: string;\n  };\n}\n\nexport const contentBundle: ContentBundle = ${serialized};\n`;
}

async function run(): Promise<void> {
  const homePosts = await collectPostsFromDir('home', 'post');
  const dailyPosts = await collectPostsFromDir('daily', 'daily');
  const posts = [...homePosts, ...dailyPosts].sort((a, b) => a.filePath.localeCompare(b.filePath));
  const aboutContent = await loadAboutContent();

  const bundle: ContentBundle = {
    generatedAt: new Date().toISOString(),
    posts,
    about: {
      content: aboutContent,
    },
  };

  await ensureDir(OUTPUT_DIR);
  await fsp.writeFile(OUTPUT_PATH, renderTypeScript(bundle), 'utf8');
  console.log(`Wrote content bundle: ${OUTPUT_PATH} (${posts.length} posts)`);
}

run().catch((error: unknown) => {
  console.error('Failed to generate content bundle:', error);
  process.exit(1);
});
